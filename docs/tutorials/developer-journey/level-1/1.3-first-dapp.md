# 1.3: 最初の開発dapp

## 概要

この時点で、canister 開発の基礎を学び、Motoko プレイグラウンドにデフォルトの 'Hello, world' プロジェクトテンプレートをデプロイしました。そろそろコードを書いて、自分自身の最初のdapp を開発しましょう！

このチュートリアルでは、バックエンドcanister とフロントエンドcanister の両方を含むポーリングdapp を作成します。要約すると、バックエンドcanisters はdapp のスマート・コントラクト・コードをホストするために使用され、フロントエンドcanisters は HTML や CSS などのユーザー・インターフェース資産をホストするために使用されます。

polldapp はエンドユーザーに質問をし、どの答えを選択するか投票させます。

## 前提条件

始める前に、「[0.3: 開発者環境のセットアップ](../level-0/03-dev-env.md)」の指示に従って開発者環境をセットアップしていることを確認してください。

## 新しいプロジェクトの作成

まず、新しい`dfx` プロジェクトを作成する必要があります。ターミナル・ウィンドウを開き、作業ディレクトリ (`developer_journey`) に移動し、コマンドを使用します：

    dfx new poll

:::info
デフォルトでは、`dfx new` はMotoko 言語で新しいプロジェクトを作成します。Rust プロジェクトを作成したい場合は、`--type=rust` フラグを使用します。
::：

## プロジェクトのファイル構造を確認

プロジェクトのファイル構造を確認してみましょう：

    poll                   # The root of the project
    ├── README.md
    ├── dfx.json           # The configuration file for your Internet Computer dapp
    ├── package-lock.json  # Node.js package configuration
    ├── package.json       # Node.js package configuration
    ├── src
    │   ├── poll_backend   # Folder containing the source code of your dapp's backend.
    │   │   └── main.mo    # The default source code file; this is what we'll primarily be working with in this tutorial.
    │   └── poll_frontend  # Folder containing the frontend configuration and assets of your dapp. 
    │       └── ...
    └── webpack.config.js  # Web dapp bundler configuration.

上のファイル構造では、`src` の中に2つのサブディレクトリがあることにお気づきでしょう。これは、`dfx new poll` を経由して`poll` というプロジェクトを作成したときに、デフォルトで**2つの** canisters が作成され、互いに通信するようになっているからです：

- `src/poll_backend` には、 のバックエンドとなるファイルが含まれています。dapp
- `src/poll_frontend` dapp のフロントエンドとなるファイルが含まれています。

このファイル構造は、`dfx` が新しいプロジェクトに作成するデフォルトのテンプレートです。フロントエンドcanister のないプロジェクトを作成したい場合は、`dfx new` コマンドで`--no-frontend` フラグを使用できます。

## バックエンドのコードを書くcanister 

dapp のバックエンドのコードを書き始めましょう。好きなコード・エディタを開き、ファイル`src/poll_backend/main.mo` を開きます。デフォルトでは、このファイルには[dfx](../level-0/06-intro-dfx.md)モジュール[入門で](../level-0/06-intro-dfx.md)説明したのと同じコードが含まれています。独自のコードを書きたいので、このファイルの内容をすべて削除してください。

### ファイルの作成actor

まず、actor を作成します。actor はカプセル化されたステートを持つプロセスであることを思い出してください。Actorはコードとデータの両方を含み、メッセージを送受信することで通信します。canister には、actor を 1 つだけ含めることができます。

`src/poll_backend/main.mo` ファイルに、以下のコードを貼り付けます：

:::caution
次の例は、より大きなコード・ファイルの一部である**コード・スニペット**です。このスニペットは、単独で実行するとエラーを返すことがあります。実行されるべき完全なコードファイルを表示するには、[最終コードを](#final-code)参照してください。
::：

``` motoko
actor {

    //actor code goes here
    
}
```

このコードはactor を定義しますが、現在は空です。データやメッセージの送受信は定義されていません。

次に、actor の中に、投票アプリの質問を提案するコードを追加してみましょう。例えば、「好きなプログラミング言語は何ですか？

この質問を追加するには、actor 定義の中に次のコードを挿入します：

:::caution
次の例は、より大きなコード・ファイルの一部である**コード・スニペット**です。このスニペットは単独で実行するとエラーを返すことがあります。実行されるべき完全なコードファイルを見るには、[final codeを](#final-code)参照してください。
::：

``` motoko
    var question: Text = "What is your favorite programming language?";
```

:::info
**このコードは何をするのでしょうか？**

まず、`question` という新しいactor 変数を作成します。

`Text`これはMotoko の文字列の規格です。
::：

型`Text` を使用しているので、Motoko ベース・ライブラリから型`Text` をインポートする必要があります。これを行うには、ファイルの先頭に import 文を追加します：

    import Text "mo:base/Text";

これらの変更後、`main.mo` ファイルは以下のようになるはずです：

:::caution
次の例は、より大きなコード・ファイルの一部である**コード・スニペット**です。このスニペットは、単独で実行するとエラーを返すことがあります。実行されるべき完全なコードファイルを表示するには、[最終コードを](#final-code)参照してください。
::：

``` motoko
import Text "mo:base/Text";

actor {
    var question: Text = "What is your favorite programming language?";

}
```

さて、このコードにはactor があり、1つの固定変数とメソッドがあります。

次のステップでは、アクセスメソッドを追加します。これは、他のcanisters やその他の外部エンティティと通信するためには、actorがメッセージを送受信する必要があるからです。

具体的には、以下のような機能を作りたいと思います：

- 現在の投票の質問を取得します。
- 投票可能な選択肢のリストを受信します。
- 投票を送信し、dapp に結果を保存させます。
- 投票数をリセットして投票を再実行します。

### `getQuestion` メソッドの定義

まず最初の機能である、現在の投票の質問を取得することから始めましょう。そのために、以下のコードで`getQuestion` メソッドを作成します：

:::caution
以下の例は、より大きなコードファイルの一部である**コードスニペット**です。このスニペットは単独で実行するとエラーを返す可能性があります。実行されるべき完全なコードファイルを表示するには、[最終コードを](#final-code)参照してください。
::：

``` motoko
public query func getQuestion() : async Text { 
    question 
};
```

:::info
**このコードは何をするのですか？**

この`getQuestion` メソッドは`question` 変数の現在値を取り、呼び出し元に返します。メソッドとその動作に関して、注意すべき重要なことがいくつかあります：

- IC上で値を返すメソッドはすべて、非同期実行を可能にするために`async` 。
- `getQuestion` メソッドはデータを変更しないので、`query` 呼び出しとして宣言できます。これについては後で詳しく説明します。
- このメソッドは、ファイルの先頭ですでにインポートした`Text` 型を使用します。
  ::：

### クエリーコールとアップデートコールの比較

**クエリーコールは**サブネットの1つのノードで実行されます。クエリー・コールを使用してデータを変更することはできません。

**アップデート・コールは**サブネットのすべてのノードで実行されます。結果はサブネット上のコンセンサスを通過する必要があり、データを変更することができます。

詳細な比較の内訳は以下を参照してください：

|  | クエリー | 更新 |
| --- | --- | --- |
| リソース消費 | 低い | 高い |
| 応答時間 | 速い (300ms-900ms) | 遅い (2s-10s) |
| コスト | 低い | コストcycles |
| データ変更 | データ変更不可 | データ変更可 |
| セキュリティ | デフォルトで認証されない結果 | デフォルトで認証[された](https://internetcomputer.org/how-it-works/asset-certification/)結果 |

`getQuestion` メソッドを追加すると、`main.mo` ファイルは次のようになります：

``` motoko
import Text "mo:base/Text";


actor {
    var question: Text = "What is your favorite programming language?";

    public query func getQuestion() : async Text { 
      question 
    };
}
```

### データを格納するデータ構造の作成

私たちの投票では、各選択肢と各選択肢の得票数に関連する数値を保存します。このデータの集まりは*キーバリューストアの*形になります。他の言語では、このデータ構造は「辞書」や「マップ」として知られています。Motoko では、このデータ構造は [`RBTree`](/motoko/main/base/RBTree.md).

`RBTree` は、 型の`Text` **投票**オプションを、 型の`Nat`**投票**数にマッピングします。 は文字列テキスト値のデータ型で、 は自然数（小数点のない整数）のデータ型です。`Text` `Nat` 

こ のデー タ 構造を視覚化す る ために、 以下の表に、 投票オプシ ョ ン`ID` を、 それに関連づけ ら れたカ レ ン ト`Vote count` にマ ッ プす る 方法を示 し ます。

たとえば、「好きなプログラミング言語は何ですか」投票のデータ構造は次のようになります：

| ID | 投票数 |
| --- | --- |
| "Motoko" | 0 |
| "Rust" | 0 |
| 「タイプスクリプト | 0 |
| "パイソン" | 0 |

### 追加の依存関係のインポート

`RBTree` データ構造を保存してクエリするには、いくつかの異なるものをインポートする必要があります。これらは以下の通りです：

- `RBTree` を使うには、`RBTree` をインポートする必要があります。
- `Nat` データ型を使用するには、`Nat` をインポートする必要があります。
- このチュートリアルの後半では、`Iter` を使用します。このパッケージは後で使用できるように、今インポートします。

これらのパッケージをインポートするには、`main.mo` ファイルの先頭に以下の import 文を追加します：

``` motoko
import RBTree "mo:base/RBTree";
import Nat "mo:base/Nat";
import Iter "mo:base/Iter";
```

### `votes` 変数の宣言

次に、actor の中に、データ構造用の変数を宣言するコードを追加する必要があります：

``` motoko
    var votes: RBTree.RBTree<Text, Nat> = RBTree.RBTree(Text.compare);
```

:::info
**このコードは何をするのでしょうか？**
このコードでは、`votes` という変数を、`RBTree.RBTree<Text, Nat>` という型で作成します。
::：

### `getVotes` メソッドの宣言

データ収集構造ができたので、オプションごとの投票数を問い合わせるメソッドを作成する必要があります。データを変更しないので、これはクエリーコールになります。

次のコードを`main.mo` ファイルに挿入します。コードのロジックを説明するのに役立つインラインコメントがあります：

:::caution
以下の例は、より大きなコード・ファイルの一部である**コード・スニペット**です。このスニペットを単独で実行するとエラーを返すことがあります。実行されるべき完全なコードファイルを表示するには、[最終コードを](#final-code)参照してください。
::：

``` motoko
// query the list of entries and votes for each one
// Example: 
//      * JSON that the frontend will receive using the values above: 
//      * [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]

    public query func getVotes() : async [(Text, Nat)] {
    
        Iter.toArray(votes.entries())
    
    };

```

:::info
**このコードは何をするのでしょうか？**

まず、`getVotes` メソッドは [`Array`](/docs/motoko/main/base/Array.md)これは、複数の値を格納するための単純なコンテナです。このコードでは、配列は`tuple` の形式で要素を保持します。タプルは、1 つの変数に複数の項目を格納します。このコードのタプルは`(Text, Nat)` 型です。

そして、`Iter` というクラスはイテレータを表します。イテレータはポインタのようなデータ構造で、データ構造の値を順次1つずつ解析することができます。このクラスは、`votes.entries()` メソッドを実行するステートメント`Iter.toArray(votes.entries())` を使用し、`RBTree` の値を表すタプル`(Text, Nat)` のイテレータを生成します。

そして、`Iter.toArray()` は`Iter<(Text,Nat)>` を`(Text, Nat)` の配列に変換する規格関数です。 このステップは、フロントエンドがイテレータではなく配列を受け取るようにするためです。
::：

### `votes` メソッドの宣言

次のステップは、canister のステートを更新するためにアップデートコールを使用する`votes` という新しいメソッドを作成することです。

次のコードを`main.mo` ファイルに挿入します。コードのロジックを説明するインラインコメントがあります：

:::caution
次の例は、より大きなコード・ファイルの一部である**コード・スニペット**です。このスニペットを単独で実行するとエラーを返すことがあります。実行されるべき完全なコードファイルを表示するには、[最終コードを](#final-code)参照してください。
::：

``` motoko
 // This method takes an entry to vote for, updates the data and returns the updated hashmap
// Example input: vote("Motoko")
// Example: 
//      * JSON that the frontend will receive using the values above: 
//      * [["Motoko","1"],["Python","0"],["Rust","0"],["TypeScript","0"]]
    
  public func vote(entry: Text) : async [(Text, Nat)] {

    //Check if the entry already has votes.
    //Note that "votes_for_entry" is of type ?Nat. This is because: 
    // * If the entry is in the RBTree, the RBTree returns a number.
    // * If the entry is not in the RBTree, the RBTree returns `null` for the new entry.
    let votes_for_entry :?Nat = votes.get(entry);
    
    //Need to be explicit about what to do when it is null or a number so every case is taken care of
    let current_votes_for_entry : Nat = switch votes_for_entry {
      case null 0;
      case (?Nat) Nat;
    };

    //once we have the number of votes, update the votes for the entry
    votes.put(entry, current_votes_for_entry + 1);

    //Return the number of votes as an array (so frontend can display it)
    Iter.toArray(votes.entries())
  };
```

:::info
**このコードは何をするのですか？**

`?Nat` データ型は、[Motoko オプションの](/docs/motoko/main/base/Option.md)データ型で、`Nat` または`null` の値です。`votes` というタイトルの`RBTree` データ構造に対してエントリーが照会されたにもかかわらず、そのエントリーが存在しない場合、`null` を返します。これが、11行目でMotoko オプションを使用している理由です。
::：

### `resetVotes` メソッドの宣言

最後に、各投票オプションのステートを 0 に戻すために使用する`resetVotes` メソッドを宣言します。

以下のコードを`main.mo` ファイルに挿入してください。コードのロジックを説明するインラインコメントがあります：

:::caution
次の例は、より大きなコードファイルの一部である**コードスニペット**です。このスニペットを単独で実行するとエラーを返すことがあります。実行されるべき完全なコードファイルを表示するには、[最終コードを](#final-code)参照してください。
::：

``` motoko
//This method resets the vote count for each option and returns the updated hashmap
// Example JSON that the frontend will get using the values above
// [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]
    
    public func resetVotes() : async [(Text, Nat)] {

      votes.put("Motoko", 0);
      votes.put("Rust", 0);
      votes.put("TypeScript", 0);
      votes.put("Python", 0);
      Iter.toArray(votes.entries())

    };
```

:::info
**このコードは何をするのですか？**
このメソッドはアップデートコールで、canister のステートを更新します。すべてのMotoko 関数はデフォルトでアップデートコールです。`func` キーワードの前に`query` キーワードがある場合のみクエリーコールです。
::：

## 最終コード

上記のステップをすべて完了すると、`main.mo` ファイルはこのようになります：

``` motoko
import RBTree "mo:base/RBTree";
import Nat "mo:base/Nat";
import Text "mo:base/Text";
import Iter "mo:base/Iter";


actor {

  var question: Text = "What is your favorite programming language?";
  var votes: RBTree.RBTree<Text, Nat> = RBTree.RBTree(Text.compare);


  public query func getQuestion() : async Text { 
    question 
  };

// query the list of entries and votes for each one
// Example: 
//      * JSON that the frontend will receive using the values above: 
//      * [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]

    public query func getVotes() : async [(Text, Nat)] {
    
        Iter.toArray(votes.entries())
    
    };



 // This method takes an entry to vote for, updates the data and returns the updated hashmap
// Example input: vote("Motoko")
// Example: 
//      * JSON that the frontend will receive using the values above: 
//      * [["Motoko","1"],["Python","0"],["Rust","0"],["TypeScript","0"]]
    
  public func vote(entry: Text) : async [(Text, Nat)] {

    //Check if the entry already has votes.
    //Note that "votes_for_entry" is of type ?Nat. This is because: 
    // * If the entry is in the RBTree, the RBTree returns a number.
    // * If the entry is not in the RBTree, the RBTree returns `null` for the new entry.
    let votes_for_entry :?Nat = votes.get(entry);
    
    //Need to be explicit about what to do when it is null or a number so every case is taken care of
    let current_votes_for_entry : Nat = switch votes_for_entry {
      case null 0;
      case (?Nat) Nat;
    };

    //once we have the number of votes, update the votes for the entry
    votes.put(entry, current_votes_for_entry + 1);

    //Return the number of votes as an array (so frontend can display it)
    Iter.toArray(votes.entries())
  };

  public func resetVotes() : async [(Text, Nat)] {
      votes.put("Motoko", 0);
      votes.put("Rust", 0);
      votes.put("TypeScript", 0);
      votes.put("Python", 0);
      Iter.toArray(votes.entries())
  };

};
```

### dapp をローカルに配置

dapp をローカルにデプロイするには、まずローカルの IC 実行環境が現在実行中であることを確認してください。ローカルの実行環境を起動する必要がある場合は、コマンドを実行してください：

``` bash
dfx start --background
```

次に、dapp をコマンドでデプロイします：

``` bash
dfx deploy
```

前のモジュールでは、[ライブ・デモを探索](1.1-live-demo.md)しながら、`--playground` フラグを使用してcanister をMotoko プレイグラウンド・ネットワークにデプロイしました。このモジュールでは、canister をローカル環境にデプロイするデフォルトのフラグを使用していません。フラグ`--network local` で指定することもできます。

さらに、`dfx deploy` コマンドでcanister 名を指定していません。デフォルトでは`poll_backend` と`poll_frontend` canisters の両方を含む`dfx.json` ファイルにリストされているcanisters をすべてデプロイします。

`dfx deploy` コマンドの出力は以下のようになります：

``` shell
URLs:
  Frontend canister via browser
    poll_frontend: http://127.0.0.1:4943/?canisterId=qsgjb-riaaa-aaaaa-aaaga-cai
  Backend canister via Candid interface:
    poll_backend: http://127.0.0.1:4943/?canisterId=qvhpv-4qaaa-aaaaa-aaagq-cai&id=qhbym-qaaaa-aaaaa-aaafq-cai
```

## 開発済みのフロントエンドコードの追加

それでは、ユーザーがdapp とやりとりするためのフロントエンドを作成しましょう。できるだけシンプルにするために、基本的なJavaScriptを使用します。

まず、`/src/poll_frontend/src/index.html` ファイルをコードエディターで開き、既存の内容を次のように置き換えてください：

``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple poll dapp hosted on an ICP canister smart contract</title>

    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        position: relative;
      }

      .title-container {
        border: 2px solid #007bff;
        background-color: #f0f0f0;
        padding: 20px;
        border-radius: 5px;
      }

      h1 {
        font-size: 32px;
        margin-bottom: 20px;
        text-align: center;
        margin-top: 0;
      }

      h2 {
        font-size: 24px;
        margin-bottom: 10px;
        text-align: center;
      }

      form {
        margin-bottom: 20px;
        border: 2px solid #8bc34a;
        padding: 20px;
        border-radius: 5px;
      }

      label {
        display: block;
        margin-bottom: 10px;
        font-size: 18px;
        text-align: left;
      }

      input[type="radio"] {
        margin-right: 5px;
      }

      button {
        padding: 10px 20px;
        background-color: #007bff;
        border: none;
        color: #fff;
        font-size: 18px;
        cursor: pointer;
        border-radius: 5px;
      }

      button#reset {
        background-color: #dc3545;
        position: absolute;
        bottom: 20px;
        left: 20px;
        margin: 10px 0; /* Add margin */
      }

      button:hover {
        background-color: #0056b3;
      }

      #results {
        margin-top: 20px;
        font-size: 18px;
        border: 2px solid #8bc34a;
        padding: 20px;
        border-radius: 5px;
        position: relative;
      }
    </style>
</head>
<body>
    <div class="container">
      <div class="title-container">
        <h1>Simple Voting Poll</h1>
      </div>
      <h2 id="question">Sample Question</h2>

      <!-- Form where users vote -->
      <div class="form-container">
        <form id="radioForm">
            <label>
                <input type="radio" name="option" value="Rust"> Rust
            </label><br>
            <label>
                <input type="radio" name="option" value="Motoko"> Motoko
            </label><br>
            <label>
                <input type="radio" name="option" value="TypeScript"> TypeScript
            </label><br>
            <label>
                <input type="radio" name="option" value="Python"> Python
            </label><br>
            <button type="submit">Vote</button>
        </form>
      </div>

      <!-- Poll results appear here-->
      <h2 id="results-title">Results</h2>
      <div id="results"></div>
    </div>
    <button id="reset">Reset Poll</button>


</body>
</html>
```

:::info
**このコードは何をするのですか？**
上の HTML コードは、エンドユーザーにラジオボタンで選択するオプションを提供する単純なフォームです。このコードには「Web3」やIC特有のものはありません。

次に、`<head>` タグを使用して、ページのスタイリングのための基本的な CSS を記述しています。スタイルシートの追加について詳しくは、[スタイルシートの追加](/docs/developer-docs/frontend/add-stylesheet.md)を参照してください。
::：

最後に、フロントエンドのcanister がバックエンドのcanister と通信し、その結果をフロントエンドの HTML に反映させるために、`index.js` ファイルを更新する必要があります。

コードエディタで`/src/poll_frontend/src/index.js` ファイルを開き、`index.js` の内容を次のように置き換えます：

``` javascript
const pollForm = document.getElementById("radioForm");
const resultsDiv = document.getElementById('results');
const resetButton = document.getElementById('reset');

import { poll_backend } from "../../declarations/poll_backend";

```

:::info
**このコードは何をするのでしょうか？**

このコードでは、`import { poll_backend } from "../../declarations/poll_backend";` という記述が、フロントエンドがバックエンドのインターフェイスcanister をインポートし、シームレスにやりとりできるようにしています。

:::

次に、バックエンドcanister にクエリを追加して、投票の質問を取得し、各選択肢の現在の投票数を取得しましょう：

``` javascript
//Load the Simple Poll's question from the backend when the app loads
document.addEventListener('DOMContentLoaded', async (e) => {
   //note that this is at beginning of the submit callback, this is deliberate
  //This is so the default behavior is set BEFORE the awaits are called below
  e.preventDefault();
 
  // Query the question from the backend
  const question = await poll_backend.getQuestion();
  document.getElementById("question").innerText = question;

  //Query the vote counts for each option
  // Example JSON that the frontend will get using the values above
  // [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]
  const voteCounts = await poll_backend.getVotes();
  updateLocalVoteCounts(voteCounts);
  displayResults();
  return false;
}, false);
```

このコードを完全に機能させるには、他にもいくつかの Javascript を追加する必要があります。最終的に、`index.js` ファイルは以下のようになります：

``` javascript
const pollForm = document.getElementById("radioForm");
const resultsDiv = document.getElementById('results');
const resetButton = document.getElementById('reset');

//Note we will use "poll_backend" in this JavaScript code a few times to call the backend
import { poll_backend } from "../../declarations/poll_backend";

//1. LOCAL DATA
const pollResults = {
    "Rust": 0,
    "Motoko": 0,
    "TypeScript": 0,
    "Python": 0
};

//2. EVENT LISTENERS

//Load the Simple Poll's question from the backend when the app loads
document.addEventListener('DOMContentLoaded', async (e) => {
   //note that this is at beginning of the submit callback, this is deliberate
  //This is so the default behavior is set BEFORE the awaits are called below
  e.preventDefault();
 
  // Query the question from the backend
  const question = await poll_backend.getQuestion();
  document.getElementById("question").innerText = question;

  //Query the vote counts for each option
  // Example JSON that the frontend will get using the values above
  // [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]
  const voteCounts = await poll_backend.getVotes();
  updateLocalVoteCounts(voteCounts);
  displayResults();
  return false;
}, false);

//Event listener that listens for when the form is submitted.
//When the form is submitted with an option, it calls the backend canister
//via "await poll_backend.vote(selectedOption)"
pollForm.addEventListener('submit', async (e) => {
  //note that this is at beginning of the submit callback, this is deliberate
  //This is so the default behavior is set BEFORE the awaits are called below
  e.preventDefault(); 

  const formData = new FormData(pollForm);
  const checkedValue = formData.get("option");

  const updatedVoteCounts = await poll_backend.vote(checkedValue);
  console.log("Returning from await...")
  console.log(updatedVoteCounts);
  updateLocalVoteCounts(updatedVoteCounts);
  displayResults();
  return false;
}, false);

resetButton.addEventListener('click', async (e) => {

    e.preventDefault();
    
    //Reset the options in the backend
    await poll_backend.resetVotes();
    const voteCounts = await poll_backend.getVotes();
    updateLocalVoteCounts(voteCounts);

    //re-render the results once the votes are reset in the backend
    displayResults();
    return false;
}, false);

//3. HELPER FUNCTIONS

//Helper vanilla JS function to create the HTML to render the results of the poll
function displayResults() {
  let resultHTML = '<ul>';
  for (let key in pollResults) {
      resultHTML += '<li><strong>' + key + '</strong>: ' + pollResults[key] + '</li>';
  }
  resultHTML += '</ul>';
  resultsDiv.innerHTML = resultHTML;
};

//This helper updates the local JS object that teh browser holds
// Example JSON that the frontend will get using the values above
  // [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]
function updateLocalVoteCounts(arrayOfVoteArrays){

  for (let voteArray of arrayOfVoteArrays) {
    //Example voteArray -> ["Motoko","0"]
    let voteOption = voteArray[0];
    let voteCount = voteArray[1];
    pollResults[voteOption] = voteCount;
  }

};
```

:::
**このコードは何をするのでしょうか？**

このコードの残りは、どのように動作するかを説明するためのコメントで注釈されています。このコードを読んで何をするのかを理解することは役に立ちますが、Javascriptの基礎に焦点を当てるのは後のチュートリアルまでお預けです。
::：

## の再デプロイdapp

コマンドでdapp をローカルに再デプロイします：

``` sh
dfx deploy
```

ターミナルの出力が以下のように表示されたら、`poll_frontend` の URL をウェブブラウザで開いてください：

```
  Frontend canister via browser
    poll_frontend: http://127.0.0.1:4943/?canisterId=avqkn-guaaa-aaaaa-qaaea-cai
  Backend canister via Candid interface:
    poll_backend: http://127.0.0.1:4943/?canisterId=asrmz-lmaaa-aaaaa-qaaeq-cai&id=by6od-j4aaa-aaaaa-qaadq-cai
```

完成したdapp はブラウザに表示され、次のようになるはずです：

![Poll dapp](../_attachments/poll-dapp.png)

おめでとうございます！おめでとうございます！あなたは今、最初の完全なdapp を開発したところです！

完成したコードのリポジトリは[こちら](https://github.com/jessiemongeon1/dev-journey-poll-dapp/tree/main)です。

## 次のステップ

このチュートリアルでは、dapp をローカル環境にデプロイしました。次のモジュールでは、dapp をInternet Computer メインネットにデプロイするために、cycles ウォレットをセットアップし、cycles を取得します。

- [1.4:cycles](1.4-using-cycles.md) の[取得と使用](1.4-using-cycles.md)

<!---
# 1.3: Developing your first dapp

## Overview

At this point in our developer journey, we've covered the fundamentals of canister development and deployed the default 'Hello, world' project template on the Motoko playground. It's time to get into writing code and developing our own first dapp! 

For this tutorial, we'll be creating a poll dapp that includes both a backend canister and a frontend canister. To recap, backend canisters are used to host the dapp's smart contract code, while frontend canisters are used to host user interface assets, such as HTML and CSS. 

The poll dapp will ask the end user a question, then have them vote on which answer they'd like to select. 

## Prerequisites

Before you start, verify that you have set up your developer environment according to the instructions in [0.3: Developer environment setup](../level-0/03-dev-env.md).

## Creating a new project

First, we need to create a new `dfx` project. Open a terminal window, navigate into your working directory (`developer_journey`), then use the command:

```
dfx new poll
```

:::info
Remember, by default `dfx new` creates a new project in the Motoko language. If you'd like to create a Rust project, use the flag `--type=rust`.
:::

## Reviewing the project's file structure

Let's review the project's file structure:

```
poll                   # The root of the project
├── README.md
├── dfx.json           # The configuration file for your Internet Computer dapp
├── package-lock.json  # Node.js package configuration
├── package.json       # Node.js package configuration
├── src
│   ├── poll_backend   # Folder containing the source code of your dapp's backend.
│   │   └── main.mo    # The default source code file; this is what we'll primarily be working with in this tutorial.
│   └── poll_frontend  # Folder containing the frontend configuration and assets of your dapp. 
│       └── ...
└── webpack.config.js  # Web dapp bundler configuration.
```

You will notice that the file structure above has two sub-directories within `src`. That is because when you created the project `poll` via `dfx new poll`, the project by default created **two** canisters that talk to each other:
- `src/poll_backend` which contains the files that serve as the backend of the dapp.
- `src/poll_frontend` which contains the files that serve as the frontend of the dapp.

This file structure is the default template `dfx` creates for a new project. If you'd like to create a project without a frontend canister, the `--no-frontend` flag can be used with the `dfx new` command. 

## Writing the backend canister code

Let's start writing the code for the backend of our dapp. Open your code editor of choice, then open the file `src/poll_backend/main.mo`. By default, this file will contain the same code we reviewed in the [introduction to dfx](../level-0/06-intro-dfx.md) module. Since we want to write our own code, delete the entire contents of this file. 

### Creating an actor 

First, we'll create an actor. Recall that an actor is a process with an encapsulated state. Actors contain both code and data, and communicate by sending and receiving messages. A canister can only contain a single actor. 

In your `src/poll_backend/main.mo` file, paste the following code:

:::caution
The following example is a **code snippet** that is part of a larger code file. This snippet may return an error if run on its own. To view the full code file that should be run, please see [final code](#final-code).
:::

```motoko
actor {

    //actor code goes here
    
}
```

This code defines an actor, but it is currently empty. It does not define any data or send and receive messages. 

Next, let's add some code inside the actor that proposes a question for our poll app. For example, we can ask the user, "What is your favorite programming language?". 

To add this question, insert the following code inside of the actor definition:

:::caution
The following example is a **code snippet** that is part of a larger code file. This snippet may return an error if run on its own. To view the full code file that should be run, please see [final code](#final-code).
:::

```motoko
    var question: Text = "What is your favorite programming language?";
```

:::info
**What does this code do?**

First, it creates a new actor variable called `question`.

Then, it declares the type of this variable as `Text`, which is the standard type for strings in Motoko. 
:::

Since we are using the type `Text`, we need to import the type `Text` from the Motoko base library. To do this, add an import statement at the top of the file:

```
import Text "mo:base/Text";
```

After all of these changes, your `main.mo` file should look like this:

:::caution
The following example is a **code snippet** that is part of a larger code file. This snippet may return an error if run on its own. To view the full code file that should be run, please see [final code](#final-code).
:::

```motoko
import Text "mo:base/Text";

actor {
    var question: Text = "What is your favorite programming language?";

}
```

Now, our code has an actor with one fixed variable and no methods. 

For our next step, we'll add access methods. This is because in order to communicate with other canisters or any other external entity, actors must send and receive messages. 

Specifically for our poll, we want to create the following functionality:

- Obtain the current poll question.
- Receive a list of possible options that can be voted on.
- Submit a vote and have the dapp save the results. 
- Reset the vote counts to re-run the poll. 

### Defining the `getQuestion` method

Let's start with the first functionality; obtain the current poll question. To do this, we'll create the `getQuestion` method using the following code:

:::caution
The following example is a **code snippet** that is part of a larger code file. This snippet may return an error if run on its own. To view the full code file that should be run, please see [final code](#final-code).
:::

```motoko
public query func getQuestion() : async Text { 
    question 
};
```

:::info
**What does this code do?**

This `getQuestion` method takes the current value of the `question` variable and returns it to the caller. There are some important things regarding methods and their behavior to be aware of, such as:

- All methods that return values on the IC have to be declared as `async` in order to allow asynchronous execution. 
- Since the `getQuestion` method doesn't change any data, it can be declared as a `query` call. We'll dive further into this shortly. 
- This method uses the `Text` type that we previously have already imported at the top of the file. 
:::

### Query calls vs. update calls

A **query call** is executed on one node of a subnet. It is not possible to use query calls to alter data.

An **update call** is executed on all nodes of a subnet. The result must pass through consensus on the subnet and has the ability to alter data. 

A detailed comparison breakdown can be found below:

|                      | Queries                    | Updates                |
|----------------------|----------------------------|------------------------|
| Resource consumption | Low                        | High                   |
| Response times       | Fast (300ms-900ms)         | Slow (2s-10s)          |
| Cost                 | Low                       | Cost cycles            |
| Data change         | Not allowed to change data | Allowed to change data |
| Security            | Results not certified by default | Results [certified by default](https://internetcomputer.org/how-it-works/asset-certification/) |


After adding the `getQuestion` method, your `main.mo` file should look like this:

```motoko
import Text "mo:base/Text";


actor {
    var question: Text = "What is your favorite programming language?";

    public query func getQuestion() : async Text { 
      question 
    };
}
```

### Creating a data structure to store the data

In our poll, we will be storing each poll option and a number associated with how many votes each option has. This collection of data will be in the form of a *key-value store*. In other languages, this data structure is known as a "dictionary" or a "map". In Motoko, this data structure is called an [`RBTree`](/motoko/main/base/RBTree.md). 

`RBTree` maps a **vote option** of type `Text` to a **vote count** of type `Nat`. `Text` is a data type for string text values, and `Nat` is a data type for natural numbers, which are whole numbers without decimal points. 

To visualize this data structure, the following table displays how a vote option `ID` can be mapped to the current `Vote count` associated with it. 

For example, the data structure for our "What is your favorite programming language?" poll may look like this:

| ID  | Vote count |
| --- | ------ |
| "Motoko"   | 0 |
| "Rust"   |   0 |
| "TypeScript"   |  0 |
| "Python"   | 0     |

### Importing additional dependencies

In order to store and query the `RBTree` data structure, we need to import a few different things. These are:

- To use `RBTree`, we need to import `RBTree`. 
- To use `Nat` data types, we need to import `Nat`. 
- Later in this tutorial we will use `Iter`, which we will import now so that it is ready to use later. 

To import these packages, add the following import statements to the beginning of the `main.mo` file:

```motoko
import RBTree "mo:base/RBTree";
import Nat "mo:base/Nat";
import Iter "mo:base/Iter";
```

### Declaring the `votes` variable
Next, we need to add some code inside the actor to declare the variable for the data structure:

```motoko
    var votes: RBTree.RBTree<Text, Nat> = RBTree.RBTree(Text.compare);
```

:::info
**What does this code do?**
In this code, we create a variable called `votes` with the type `RBTree.RBTree<Text, Nat>`.
:::

### Declaring the `getVotes` method

Now that we have the data collection structure, we need to create a method that queries the amount of vote counts per option. This will be a query call, since it will not alter the data. 

Insert the following code into your `main.mo` file; there are inline comments that help explain the code's logic:

:::caution
The following example is a **code snippet** that is part of a larger code file. This snippet may return an error if run on its own. To view the full code file that should be run, please see [final code](#final-code).
:::


```motoko
// query the list of entries and votes for each one
// Example: 
//      * JSON that the frontend will receive using the values above: 
//      * [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]

    public query func getVotes() : async [(Text, Nat)] {
    
        Iter.toArray(votes.entries())
    
    };

```

:::info
**What does this code do?**

First, the `getVotes` method returns an [`Array`](/docs/motoko/main/base/Array.md), which is a simple container used to store multiple values. In this code, the array holds elements in that are in the form of a `tuple`. A tuple stores multiple items in a single variable. The tuples in this code are of type `(Text, Nat)`.

Then, the class `Iter` represents an iterator, which is a pointer-like data structure allowing for the data structure's values to be parsed one by one in a sequential manner. This class uses the statement `Iter.toArray(votes.entries())` which executes the `votes.entries()` method, and then produces an iterator of tuples `(Text, Nat)` that represent the `RBTree`'s values. 

Then, the `Iter.toArray()` is a standard function that converts `Iter<(Text,Nat)>` to an array of `(Text, Nat)`. This step is so that the frontend receives an array instead of an iterator.
:::


### Declaring the `votes` method

Our next step is to create a new method called `votes` that uses an update call to update the canister's state. 

Insert the following code into your `main.mo` file; there are inline comments that help explain the code's logic:

:::caution
The following example is a **code snippet** that is part of a larger code file. This snippet may return an error if run on its own. To view the full code file that should be run, please see [final code](#final-code).
:::


```motoko
 // This method takes an entry to vote for, updates the data and returns the updated hashmap
// Example input: vote("Motoko")
// Example: 
//      * JSON that the frontend will receive using the values above: 
//      * [["Motoko","1"],["Python","0"],["Rust","0"],["TypeScript","0"]]
    
  public func vote(entry: Text) : async [(Text, Nat)] {

    //Check if the entry already has votes.
    //Note that "votes_for_entry" is of type ?Nat. This is because: 
    // * If the entry is in the RBTree, the RBTree returns a number.
    // * If the entry is not in the RBTree, the RBTree returns `null` for the new entry.
    let votes_for_entry :?Nat = votes.get(entry);
    
    //Need to be explicit about what to do when it is null or a number so every case is taken care of
    let current_votes_for_entry : Nat = switch votes_for_entry {
      case null 0;
      case (?Nat) Nat;
    };

    //once we have the number of votes, update the votes for the entry
    votes.put(entry, current_votes_for_entry + 1);

    //Return the number of votes as an array (so frontend can display it)
    Iter.toArray(votes.entries())
  };
```

:::info
**What does this code do?**

The `?Nat` data type is a [Motoko optional](/docs/motoko/main/base/Option.md) data type that may be a `Nat` or a `null` value. If an entry is queried for the `RBTree` data structure titled `votes`, but the entry is not present, it will return `null`. That is why we use a Motoko optional in line 11.
:::

### Declaring the `resetVotes`  method

Lastly, we'll declare the `resetVotes` method that'll be used to reset the state of each vote option back to 0. 

Insert the following code into your `main.mo` file; there are inline comments that help explain the code's logic:

:::caution
The following example is a **code snippet** that is part of a larger code file. This snippet may return an error if run on its own. To view the full code file that should be run, please see [final code](#final-code).
:::

```motoko
//This method resets the vote count for each option and returns the updated hashmap
// Example JSON that the frontend will get using the values above
// [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]
    
    public func resetVotes() : async [(Text, Nat)] {

      votes.put("Motoko", 0);
      votes.put("Rust", 0);
      votes.put("TypeScript", 0);
      votes.put("Python", 0);
      Iter.toArray(votes.entries())

    };
```

:::info
**What does this code do?**
This method is an update call, as it updates the canister's state. All Motoko functions are update calls by default; they are only query calls when they have the `query` keyword before the `func` keyword.
:::

## Final code

Once you completed all of the above steps, your `main.mo` file should look like this:

```motoko
import RBTree "mo:base/RBTree";
import Nat "mo:base/Nat";
import Text "mo:base/Text";
import Iter "mo:base/Iter";


actor {

  var question: Text = "What is your favorite programming language?";
  var votes: RBTree.RBTree<Text, Nat> = RBTree.RBTree(Text.compare);


  public query func getQuestion() : async Text { 
    question 
  };

// query the list of entries and votes for each one
// Example: 
//      * JSON that the frontend will receive using the values above: 
//      * [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]

    public query func getVotes() : async [(Text, Nat)] {
    
        Iter.toArray(votes.entries())
    
    };



 // This method takes an entry to vote for, updates the data and returns the updated hashmap
// Example input: vote("Motoko")
// Example: 
//      * JSON that the frontend will receive using the values above: 
//      * [["Motoko","1"],["Python","0"],["Rust","0"],["TypeScript","0"]]
    
  public func vote(entry: Text) : async [(Text, Nat)] {

    //Check if the entry already has votes.
    //Note that "votes_for_entry" is of type ?Nat. This is because: 
    // * If the entry is in the RBTree, the RBTree returns a number.
    // * If the entry is not in the RBTree, the RBTree returns `null` for the new entry.
    let votes_for_entry :?Nat = votes.get(entry);
    
    //Need to be explicit about what to do when it is null or a number so every case is taken care of
    let current_votes_for_entry : Nat = switch votes_for_entry {
      case null 0;
      case (?Nat) Nat;
    };

    //once we have the number of votes, update the votes for the entry
    votes.put(entry, current_votes_for_entry + 1);

    //Return the number of votes as an array (so frontend can display it)
    Iter.toArray(votes.entries())
  };

  public func resetVotes() : async [(Text, Nat)] {
      votes.put("Motoko", 0);
      votes.put("Rust", 0);
      votes.put("TypeScript", 0);
      votes.put("Python", 0);
      Iter.toArray(votes.entries())
  };

};
```

### Deploying the dapp locally

To deploy your dapp locally, first assure that your local IC execution environment is currently running. If you need to start the local execution environment, run the command:

```bash
dfx start --background
```

Then, you can deploy the dapp with the command:

```bash
dfx deploy
```

You may recall that in the previous module, [exploring a live demo](1.1-live-demo.md), we used the `--playground` flag to deploy our canister to the Motoko playground network. In this module, we aren't using any flags, which defaults to deploying the canister to the local environment. You can also specify this with the flag `--network local`. 

Additionally, we aren't specifying a canister name in the `dfx deploy` command, which will deploy all canisters listed in the `dfx.json` file, which by default includes both the `poll_backend` and `poll_frontend` canisters. 

The output of the `dfx deploy` command will resemble the following:

```shell
URLs:
  Frontend canister via browser
    poll_frontend: http://127.0.0.1:4943/?canisterId=qsgjb-riaaa-aaaaa-aaaga-cai
  Backend canister via Candid interface:
    poll_backend: http://127.0.0.1:4943/?canisterId=qvhpv-4qaaa-aaaaa-aaagq-cai&id=qhbym-qaaaa-aaaaa-aaafq-cai
```

## Adding pre-developed frontend code

Now let's create a frontend for users to interact with our dapp. We will use some basic JavaScript to keep it as simple as possible. 

Start by opening the file `/src/poll_frontend/src/index.html` in your code editor, then replace the existing content with the following:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple poll dapp hosted on an ICP canister smart contract</title>

    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        position: relative;
      }

      .title-container {
        border: 2px solid #007bff;
        background-color: #f0f0f0;
        padding: 20px;
        border-radius: 5px;
      }

      h1 {
        font-size: 32px;
        margin-bottom: 20px;
        text-align: center;
        margin-top: 0;
      }

      h2 {
        font-size: 24px;
        margin-bottom: 10px;
        text-align: center;
      }

      form {
        margin-bottom: 20px;
        border: 2px solid #8bc34a;
        padding: 20px;
        border-radius: 5px;
      }

      label {
        display: block;
        margin-bottom: 10px;
        font-size: 18px;
        text-align: left;
      }

      input[type="radio"] {
        margin-right: 5px;
      }

      button {
        padding: 10px 20px;
        background-color: #007bff;
        border: none;
        color: #fff;
        font-size: 18px;
        cursor: pointer;
        border-radius: 5px;
      }

      button#reset {
        background-color: #dc3545;
        position: absolute;
        bottom: 20px;
        left: 20px;
        margin: 10px 0; /* Add margin */
      }

      button:hover {
        background-color: #0056b3;
      }

      #results {
        margin-top: 20px;
        font-size: 18px;
        border: 2px solid #8bc34a;
        padding: 20px;
        border-radius: 5px;
        position: relative;
      }
    </style>
</head>
<body>
    <div class="container">
      <div class="title-container">
        <h1>Simple Voting Poll</h1>
      </div>
      <h2 id="question">Sample Question</h2>

      <!-- Form where users vote -!->
      <div class="form-container">
        <form id="radioForm">
            <label>
                <input type="radio" name="option" value="Rust"> Rust
            </label><br>
            <label>
                <input type="radio" name="option" value="Motoko"> Motoko
            </label><br>
            <label>
                <input type="radio" name="option" value="TypeScript"> TypeScript
            </label><br>
            <label>
                <input type="radio" name="option" value="Python"> Python
            </label><br>
            <button type="submit">Vote</button>
        </form>
      </div>

      <!-- Poll results appear here-!->
      <h2 id="results-title">Results</h2>
      <div id="results"></div>
    </div>
    <button id="reset">Reset Poll</button>


</body>
</html>
```

:::info
**What does this code do?**
The HTML code above is a simple form that provides the end user with options to select using radio buttons. There is nothing 'Web3' or specific to the IC about this code.

Then, the `<head>` tag is used to include some basic CSS for the page's styling. To learn more about adding a stylesheet, see: [add a stylesheet](/docs/developer-docs/frontend/add-stylesheet.md).
:::

Lastly, we need to update the `index.js` file in order for our frontend canister to communicate with our backend canister and have the result of that communication reflected within the frontend's HTML. 

Open the `/src/poll_frontend/src/index.js` file in your code editor and replace the content of `index.js` with the following:


```javascript
const pollForm = document.getElementById("radioForm");
const resultsDiv = document.getElementById('results');
const resetButton = document.getElementById('reset');

import { poll_backend } from "../../declarations/poll_backend";

```

:::info
**What does this code do?**

In this code, the statement `import { poll_backend } from "../../declarations/poll_backend";` is what allows the frontend to import an interface for the backend canister and seamlessly interact with it. 

:::

Next, let's add a query to our backend canister to get the poll's question, and a query to get the current vote count for each option:

```javascript
//Load the Simple Poll's question from the backend when the app loads
document.addEventListener('DOMContentLoaded', async (e) => {
   //note that this is at beginning of the submit callback, this is deliberate
  //This is so the default behavior is set BEFORE the awaits are called below
  e.preventDefault();
 
  // Query the question from the backend
  const question = await poll_backend.getQuestion();
  document.getElementById("question").innerText = question;

  //Query the vote counts for each option
  // Example JSON that the frontend will get using the values above
  // [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]
  const voteCounts = await poll_backend.getVotes();
  updateLocalVoteCounts(voteCounts);
  displayResults();
  return false;
}, false);
```

To make this code fully functional, we'll need to add a few other pieces of Javascript. Ultimately, your `index.js` file will need to look like this:

```javascript
const pollForm = document.getElementById("radioForm");
const resultsDiv = document.getElementById('results');
const resetButton = document.getElementById('reset');

//Note we will use "poll_backend" in this JavaScript code a few times to call the backend
import { poll_backend } from "../../declarations/poll_backend";

//1. LOCAL DATA
const pollResults = {
    "Rust": 0,
    "Motoko": 0,
    "TypeScript": 0,
    "Python": 0
};

//2. EVENT LISTENERS

//Load the Simple Poll's question from the backend when the app loads
document.addEventListener('DOMContentLoaded', async (e) => {
   //note that this is at beginning of the submit callback, this is deliberate
  //This is so the default behavior is set BEFORE the awaits are called below
  e.preventDefault();
 
  // Query the question from the backend
  const question = await poll_backend.getQuestion();
  document.getElementById("question").innerText = question;

  //Query the vote counts for each option
  // Example JSON that the frontend will get using the values above
  // [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]
  const voteCounts = await poll_backend.getVotes();
  updateLocalVoteCounts(voteCounts);
  displayResults();
  return false;
}, false);

//Event listener that listens for when the form is submitted.
//When the form is submitted with an option, it calls the backend canister
//via "await poll_backend.vote(selectedOption)"
pollForm.addEventListener('submit', async (e) => {
  //note that this is at beginning of the submit callback, this is deliberate
  //This is so the default behavior is set BEFORE the awaits are called below
  e.preventDefault(); 

  const formData = new FormData(pollForm);
  const checkedValue = formData.get("option");

  const updatedVoteCounts = await poll_backend.vote(checkedValue);
  console.log("Returning from await...")
  console.log(updatedVoteCounts);
  updateLocalVoteCounts(updatedVoteCounts);
  displayResults();
  return false;
}, false);

resetButton.addEventListener('click', async (e) => {

    e.preventDefault();
    
    //Reset the options in the backend
    await poll_backend.resetVotes();
    const voteCounts = await poll_backend.getVotes();
    updateLocalVoteCounts(voteCounts);

    //re-render the results once the votes are reset in the backend
    displayResults();
    return false;
}, false);

//3. HELPER FUNCTIONS

//Helper vanilla JS function to create the HTML to render the results of the poll
function displayResults() {
  let resultHTML = '<ul>';
  for (let key in pollResults) {
      resultHTML += '<li><strong>' + key + '</strong>: ' + pollResults[key] + '</li>';
  }
  resultHTML += '</ul>';
  resultsDiv.innerHTML = resultHTML;
};

//This helper updates the local JS object that teh browser holds
// Example JSON that the frontend will get using the values above
  // [["Motoko","0"],["Python","0"],["Rust","0"],["TypeScript","0"]]
function updateLocalVoteCounts(arrayOfVoteArrays){

  for (let voteArray of arrayOfVoteArrays) {
    //Example voteArray -> ["Motoko","0"]
    let voteOption = voteArray[0];
    let voteCount = voteArray[1];
    pollResults[voteOption] = voteCount;
  }

};
```

:::
**What does this code do?**

The remainder of this code is annotated with comments to help explain how it works. It can be helpful to read through and understand what this code does, but we will not be focusing on the fundamentals of Javascript until a later tutorial.
:::

## Re-deploying the dapp

Re-deploy the dapp locally with the command:

```sh
dfx deploy
```

Now, when the terminal's output displays the following, open the `poll_frontend` URL in a web browser:

```
  Frontend canister via browser
    poll_frontend: http://127.0.0.1:4943/?canisterId=avqkn-guaaa-aaaaa-qaaea-cai
  Backend canister via Candid interface:
    poll_backend: http://127.0.0.1:4943/?canisterId=asrmz-lmaaa-aaaaa-qaaeq-cai&id=by6od-j4aaa-aaaaa-qaadq-cai
```

Your finished dapp should be displayed in the browser and look like this:

![Poll dapp](../_attachments/poll-dapp.png)

Congratulations! You've just developed your first full dapp!

You can find the finish code's repo [here](https://github.com/jessiemongeon1/dev-journey-poll-dapp/tree/main) for you to clone or fork. 
## Next steps

In this tutorial, we only deployed our dapp to our local environment. In the next module, we'll set up a cycles wallet and acquire cycles in order for us to deploy our dapp to the Internet Computer mainnet. 

- [1.4: Acquiring and using cycles](1.4-using-cycles.md).
-->
